# 前言

谈到链表之前，先说一下线性表。线性表是最基本、最简单、也是最常用的一种数据结构。线性表中数据元素之间

的关系是一对一的关系，即除了第一个和最后一个数据元素之外，其它数据元素都是首尾相接的。线性表有两种存

储方式，一种是顺序存储结构，另一种是链式存储结构。顺序存储结构就是两个相邻的元素在内存中也是相邻的。

这种存储方式的优点是查询的时间复杂度为 O(1)，通过首地址和偏移量就可以直接访问到某元素，关于查找的适

配算法很多，最快可以达到 O(logn)。缺点是插入和删除的时间复杂度最坏能达到 O(n)，如果你在第一个位置插入

一个元素，你需要把数组的每一个元素向后移动一位，如果你在第一个位置删除一个元素，你需要把数组的每一个

元素向前移动一位。还有一个缺点，就是当你不确定元素的数量时，你开的数组必须保证能够放下元素最大数量，

遗憾的是如果实际数量比最大数量少很多时，你开的数组没有用到的内存就只能浪费掉了。链式存储结构就是两个

相邻的元素在内存中可能不是相邻的，每一个元素都有一个指针域，指针域一般是存储着到下一个元素的指针。这

种存储方式的优点是插入和删除的时间复杂度为 O(1)，不会浪费太多内存，添加元素的时候才会申请内存，删除

元素会释放内存。缺点是访问的时间复杂度最坏为 O(n)，关于查找的算法很少，一般只能遍历，这样时间复杂度

也是线性（O(n)）的了,频繁的申请和释放内存也会消耗时间。顺序表的特性是随机读取，也就是访问一个元素的

时间复杂度是 O(1)，链式表的特性是插入和删除的时间复杂度为 O(1)。要根据实际情况去选取适合自己的存储结

构。

## 链表

链表是用于存储项目列表的有序元素的集合，链式存储的线性表。 与数组不同，链表可以动态扩展和收缩。链表

还可以用作其他数据结构（例如堆栈和队列）的基础。 列表可用于存储用户，汽车零件，原料，待办事项和各种

其他此类元素的列表。 链表是最常用的线性数据结构。根据指针域的不同，链表分为单向链表、双向链表、循环

链表等等。

## 单链表 Linked List

单链表的特点是链表的链接方向是单向的，对链表的访问要通过从头部开始，依序往下读取。一个单链表的节点被

分为两个部分。第一个部分保存或者显示关于节点的信息，第二个部分存储下一个节点的地址，单链表只可向一个

方向遍历。不同操作在单链表的时间复杂度

```
Access(存取) ---- O(n)
Search(搜索) ---- O(n)
Insert(插入) ---- O(1)
Delete(删除) ---- O(1)
```

### Node 节点

Node 节点是一个结构体 Struct，结构体的第一个成员是个整形 int 的字段 property，这里根据你的需求来不一

定是整形也不一定要叫 property:)。第二个成员是指向下一个节点的指针。

```Go
type Node struct{
  property int
  nextNode *node
}
```

### 定义单链表

```GO
type LinkedList struct{
  // 单链表的首节点
  headNode *Node
}
```

下面列出 LinkedList 的一些方法，例如 AddtoHead，IterateList，LastNode，AddtoEnd，NodeWithValue，AddAfter

### AddToHead 方法

AddToHead 方法将节点添加到单链表的开头。单链表的 AddToHead 方法具有参数 integer 属性。该属性用于初始

化节点。 实例化一个新节点，并将其属性设置为传递的属性参数。 nextNode 指向链表的当前 headNode，并将

headNode 设置为所创建的新节点的指针，如以下代码所示：

```go
// 添加到头部方法
func (linkedList *LinkedList) AddToHead(property int) {
	node := Node{}
	node.property = property
	if node.nextNode != nil {
		node.nextNode = linkedList.headNode
	}
	linkedList.headNode = &node
}

func main() {
	linkedList := LinkedList{}
	linkedList.AddToHead(1)
	linkedList.AddToHead(3)
	fmt.Println(linkedList.headNode.property)
}

```
